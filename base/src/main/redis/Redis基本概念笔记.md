# redis的两种持久化方式
1. rdb：以快照的形式，将数据存储在内存中，效率高，但是容易丢失数据。相当于mysql的dump
   + RDB方式的持久化是通过快照(snapshortting)完成的，当符合一定条件时Redis会自动将内存中所有数据完整的压缩存储到硬盘上。
   + RDB开启条件由2个参数 时间 和 改动次数构成。如：save 900 1
   + RDB文件由2个参数 dir 和 dbfilename 分别指定目录 和 文件名
   + RDB方式是Redis默认的持久化方式。
2. aof：写日志方式，相当于 MySQL 中的 binlog，推荐使用。
   + AOF是纯文本文件，会记录 Redis 的每次改动命令(不记录查询)。
   + AOF开启条件：appendonly yes
   + AOF文件由2个参数 dir 和 appendfilename 分别指定目录 和 文件名
   + AOF方式 默认情况下Redis并没有开启。
   + 策略：
      + 策略1：always(每次写入都会fsync同步到硬盘)
      + 策略2：everysec(默认，1s写1次)
      + 策略3：no(并非不写，交给系统控制预计30s写1次)
      
---
# Redis 的数据“过期”策略
1. 被动删除：当读/写一个已经过期的 key 时，会触发惰性删除策略，直接删除掉这个过期 key 。
2. 主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以 Redis 会定期主动淘汰一批已过期的 key 。
3. 主动删除：当前已用内存超过 maxmemory 限定时，触发主动清理策略，即 「数据“淘汰”策略」 。


---      
#  Redis集群机制
## 主从复制
1. 主服务器可以读写数据，从服务器只能读取数据
2. 初始化时，从服务器向主服务器发送sync命令，同步rdb快照数据
3. 然后将保存的快照文件和缓存的命令发送给slave
4. slave接收到快照文件和命令后加载快照文件和缓存的执行命令。
5. 复制初始化后，master每次接收到的写命令都会同步发送给slave，保证主从数据一致性。


## 哨兵
哨兵的作用是监控 redis系统的运行状况，他的功能如下：  
1. 集群监控：负责监控 redis master 和 slave 进程是否正常工作。
2. 消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。
3. 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。
4. 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。

### 工作方式：  
1. 每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。
2. 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）
3. 如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态
4. 当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）
5. 在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。
6. 当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。
7. 若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。

###  哨兵模式的优缺点
1. 优点
   + 哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。
   + 主从可以自动切换，系统更健壮，可用性更高。
   + 读写分离

2. 缺点
   + Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。
   + 每个服务器存储数据相同，浪费内存


## 集群
redis3.0上加入了cluster模式，实现的redis的分布式存储，也就是说每台redis节点上存储不同的内容。  
Redis-Cluster采用无中心结构,它的特点如下：  
1. 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。
2. 节点的fail是通过集群中超过半数的节点检测失效时才生效。
3. 客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。
   
### 工作方式
```
在redis的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383。
还有一个就是cluster，可以理解为是一个集群管理的插件。
当我们的存取的key到达的时候，redis会根据crc16的算法得出一个结果，然后把结果对 16384 求余数，
这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，
然后直接自动跳转到这个对应的节点上进行存取操作。
```
   
```
为了保证高可用，redis-cluster集群引入了主从模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。
当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。
如果主节点A和它的从节点A1都宕机了，那么该集群就无法再提供服务了。
```

### Redis的Hash一致性
#### 场景1
1. 如果4台缓存服务器已经不能满足我们的缓存需求，那么我们应该怎么做呢？
2. 假设：我们增加了一台缓存服务器，那么缓存服务器的数量就由4台变成了5台。
3. 那么原本hash(a.png) % 4 = 2 的公式就变成了hash(a.png) % 5 = ？ ， 可想而知这个结果肯定不是2的，这种情况带来的结果就是当服务器数量变动时，所有缓存的位置都要发生改变！
4. 换句话说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端数据库请求数据

#### 场景2
1. 假设4台缓存中突然有一台缓存服务器出现了故障，无法进行缓存，那么我们则需要将故障机器移除，
2. 但是如果移除了一台缓存服务器，那么缓存服务器数量从4台变为3台，也是会出现上述的问题！

#### 槽迁移
1. 当出现以上场景的时候，则需要进程槽solt的迁移
2. 槽迁移的过程中有一个不稳定状态，这个不稳定状态会有一些规则，这些规则定义客户端的行为，从而使得Redis Cluster不必宕机的情况下可以执行槽的迁移。
3. 数据转出槽，MIGRATING状态下当客户端请求的某个Key所属的槽处于MIGRATING状态的时候，影响有下面几条：
    + 如果Key存在则成功处理
    + 如果Key不存在，则返回客户端ASK，仅当这次请求会转向另一个节点，并不会刷新客户端中node的映射关系，也就是说下次该客户端请求该Key的时候，还会选择MasterA节点
    + 如果Key包含多个命令，如果都存在则成功处理，如果都不存在，则返回客户端ASK，如果一部分存在，则返回客户端TRYAGAIN，通知客户端稍后重试，这样当所有的Key都迁移完毕的时候客户端重试请求的时候回得到ASK，然后经过一次重定向就可以获取这批键
4. 数据转入槽，IMPORTING状态
    + 正常命令会被MOVED重定向，如果是ASKING命令则命令会被执行，从而Key没有在老的节点已经被迁移到新的节点的情况可以被顺利处理；
    + 如果Key不存在则新建
    + 没有ASKING的请求和正常请求一样被MOVED，这保证客户端node映射关系出错的情况下不会发生写错；

#### 键空间迁移
1. 键空间迁移是指当满足了槽迁移前提的情况下，我们就可以通过相关命令将槽1、2、3中的键空间从MasterA节点转移到MasterB节点，这个过程真正实现数据转移 
2. 通过dump，restore,del三部操作进行key空间的转移
![V84QSA.png](https://s2.ax1x.com/2019/06/02/V84QSA.png)
2. [资料链接](https://blog.csdn.net/tianpeng341204/article/details/78963850)





---

# 缓存穿透
1. 缓存穿透：
   + 当请求进入时候，首先去查询key是否存在，如果不存在，则进行数据库查询
   + 但是当每次以这个key访问时，都会去查询一下数据库，这叫做缓存穿透
2. 处理方案：
   + 首先当这个key第一次查询过数据库之后，给这个key设置一个值（设置失效时间）
   + 然后再次请求时候，会获取到这个key对应的值，即不需要多次查询数据库

缓存穿透：查询一个必然不存在的数据。比如文章表，查询一个不存在的id，每次都会访问DB，如果有人恶意破坏，很可能直接对DB造成影响。

# 缓存击穿(缓存并发)
1. 缓存击穿：
   + 是指某个极度“热点”数据在某个时间点过期时，恰好在这个时间点对这个 KEY 有大量的并发请求过来，这些请求发现缓存过期一般都会从 DB 加载数据并回设到缓存，
   + 但是这个时候大并发的请求可能会瞬间 DB 压垮。
   + 对于一些设置了过期时间的 KEY ，如果这些 KEY 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑这个个问题。
   + 缓存被“击穿”的问题，和缓存“雪崩“”的区别在于，前者针对某一 KEY 缓存，后者则是很多 KEY 
   + 缓存被“击穿”的问题，和缓存“穿透“”的区别在于，这个 KEY 是真实存在对应的值的。
2. 处理方案
   + 方案一：使用互斥锁：请求发现缓存不存在后，去查询 DB 前，使用分布式锁，保证有且只有一个线程去查询 DB ，并更新到缓存。
     + 获取分布式锁，直到成功或超时。如果超时，则抛出异常，返回。如果成功，继续向下执行。
     + 再去缓存中。如果存在值，则直接返回；如果不存在，则继续往下执行。 因为，获得到锁，可能已经被“那个”线程去查询过 DB ，并更新到缓存中了
     + 查询 DB ，并更新到缓存中，返回值。
   + 方案二：手动过期
     + 缓存上从不设置过期时间，功能上将过期时间存在 KEY 对应的 VALUE 里，
     + 如果发现要过期，通过一个后台的异步线程进行缓存的构建，也就是“手动”过期。通过后台的异步线程，保证有且只有一个线程去查询 DB



# 缓存雪崩(缓存失效)
1. 缓存雪崩：
   + 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。    
   + 和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。
2. 处理方案：
   + 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
   + 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。
   + 设置热点数据永远不过期


# 缓存失效(缓存雪崩)
1. 缓存失效：假如已有缓存的失效时间都是一样的，当某个时间，所以缓存同时失效了，此时又有较高的并发，会导致所有请求，初次都去db查询，导致db压力过大。
2. 处理方案：
   + 设置随机失效时间
   + 采用缓存并发的处理方案（加锁）
3. 缓存失效：
   + 如果缓存集中在一段时间内失效，DB的压力凸显。这个没有完美解决办法，但可以分析用户行为，尽量让失效时间点均匀分布。
   + 当发生大量的缓存穿透，例如对某个失效的缓存的大并发访问就造成了缓存雪崩。


# 缓存预热
1. 缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！
2. 解决思路：
    + 直接写个缓存刷新页面，上线时手工操作下；
    + 数据量不大，可以在项目启动的时候自动进行加载；
    + 定时刷新缓存；

---

# Redis 有几种数据“过期”策略
1. 被动删除：当读/写一个已经过期的 key 时，会触发惰性删除策略，直接删除掉这个过期 key 。
2. 主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以 Redis 会定期主动淘汰一批已过期的 key 。
3. 主动删除：当前已用内存超过 maxmemory 限定时，触发主动清理策略，即 「数据“淘汰”策略」 。


# redis 提供 6种数据淘汰策略
1. volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
5. allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
6. no-enviction（驱逐）：禁止驱逐数据

---
# 如何使用 Redis 实现分布式锁？
## 方案一：set 指令
1. 先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。
> SET key value [EX seconds] [PX milliseconds] [NX|XX]


## 对比 Zookeeper 分布式锁
1. 从可靠性上来说，Zookeeper 分布式锁好于 Redis 分布式锁。
2. 从性能上来说，Redis 分布式锁好于 Zookeeper 分布式锁。


---
# redis的集群机制
1. Replication（主从复制）
2. Sentinel（哨兵）
3. Twemproxy
4. Codis
5. Redis 3.0集群

---

# redis为什么这么快
1. 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；
2. 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；
3. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
4. 使用多路I/O复用模型，非阻塞IO；
5. 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

多路 I/O 复用模型：
1. 多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。
2. 这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。

# 为什么redis是单线程的
1. 官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。
2. 我们已经可以很清楚的解释了为什么Redis这么快，并且正是由于在单线程模式的情况下已经很快了，就没有必要在使用多线程了！但是，我们使用单线程的方式是无法发挥多核CPU 性能，不过我们可以通过在单机开多个Redis 实例来完善！



---


# Redis的线程模型
redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。  
它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。  
文件事件处理器的结构包含 4 个部分：  
1. 多个 socket
2. IO 多路复用程序
3. 文件事件分派器
4. 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

