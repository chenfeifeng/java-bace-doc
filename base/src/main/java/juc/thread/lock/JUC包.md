# JUC包常用类使用说明
## Condition
1. 在没有 Lock 之前，我们使用 synchronized 来控制同步，配合 Object 的 #wait()、#notify() 等一系列方法可以实现等待 / 通知模式。  
   在 Java SE 5 后，Java 提供了 Lock 接口，相对于 synchronized 而言，Lock 提供了条件 Condition ，对线程的等待、唤醒操作更加详细和灵活。下图是 Condition 与 Object 的监视器方法的对比（摘自《Java并发编程的艺术》）
2. ![图片](http://static2.iocoder.cn/e7e7bb0837bbe68a4364366d4ec9c5db)
3. 为线程提供了一种更为灵活的等待 / 通知模式，线程在调用 await 方法后执行挂起操作，直到线程等待的某个条件为真时才会被唤醒。
4. Condition 必须要配合 Lock 一起使用，因为对共享状态变量的访问发生在多线程环境下。
5. 一个 Condition 的实例必须与一个 Lock 绑定，因此 Condition 一般都是作为 Lock 的内部实现。


## CountDownLatch
1. CountDownLatch ，字面意思是减小计数（CountDown）的门闩（Latch）。
2. 它要做的事情是，等待指定数量的计数被减少，意味着门闩被打开，然后进行执行。
3. CountDownLatch 默认的构造方法是 CountDownLatch(int count) ，其参数表示需要减少的计数，
   + 主线程调用 #await() 方法告诉 CountDownLatch 阻塞等待指定数量的计数被减少，
   + 然后其它线程调用 CountDownLatch 的 #countDown() 方法，减小计数(不会阻塞)。
   + 等待计数被减少到零，主线程结束阻塞等待，继续往下执行。
   

## CyclicBarrier
1. CyclicBarrier ，字面意思是可循环使用（Cyclic）的屏障（Barrier）。
   + 它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，
   + 直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。

2. CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties) ，
   + 其参数表示屏障拦截的线程数量，每个线程调用 #await() 方法告诉 CyclicBarrier 我已经到达了屏障，
   + 然后当前线程被阻塞，直到 parties 个线程到达，结束阻塞。


## LockSupport
1. LockSupport 是 JDK 中比较底层的类，用来创建锁和其他同步工具类的基本线程阻塞。
2. Java 锁和同步器框架的核心 AQS(AbstractQueuedSynchronizer)，就是通过调用 LockSupport#park()和 LockSupport#unpark() 方法，来实现线程的阻塞和唤醒的。
3. LockSupport 很类似于二元信号量(只有 1 个许可证可供使用)，如果这个许可还没有被占用，当前线程获取许可并继续执行；如果许可已经被占用，当前线程阻塞，等待获取许可。


## Semaphore
1. Semaphore ，是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。
2. 如有必要，在许可可用前会阻塞每一个 #acquire() 方法，然后再获取该许可。
3. 每个 #release() 方法，添加一个许可，从而可能释放一个正在阻塞的获取者。
4. 但是，不使用实际的许可对象，Semaphore 只对可用许可的数量进行计数，并采取相应的行动。
5. 信号量常常用于多线程的代码中，比如数据库连接池。
> #acquire()获取许可，当许可获取不到的时候，进行则，等待#release()的归还


## ReadWriteLock 
1. ReadWriteLock ，读写锁是，用来提升并发程序性能的锁分离技术的 Lock 实现类。
2. 可以用于 “多读少写” 的场景，读写锁支持多个读操作并发执行，写操作只能由一个线程来操作。
3. 可以多个线程同时获取到读锁，但是只能有一个写锁。

### ReadWriteLock 对程序性能的提高主要受制于如下几个因素：
1. 数据被读取的频率与被修改的频率相比较的结果。
2. 读取和写入的时间
3. 有多少线程竞争
4. 是否在多处理机器上运行



# 死锁
死锁，是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

## 死锁产生的原因
1. 系统资源不足
2. 进程允许顺序不合适
3. 资源分配不当

## 死锁产生的条件
1. 互斥条件:所谓互斥就是进程在某一时间内独占资源。
2. 请求与保持条件：一个进程因等待资源进行阻塞的时候，对已获得资源保持不放
3. 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系


## 死锁的解决方法
1. 撤消陷于死锁的全部进程。
2. 逐个撤消陷于死锁的进程，直到死锁不存在。
3. 从陷于死锁的进程中逐个强迫放弃所占用的资源，直至死锁消失。
4. 从另外一些进程那里强行剥夺足够数量的资源分配给死锁进程，以解除死锁状态。

## 悲观锁
悲观锁：总是假设最坏的情况，每次去拿数据的时候认为都认为别人会修改，所以每次在拿数据的时候会上锁，这样别人就不能拿到这个数据，直到他开锁。
```
1. 传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
2. 再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。

```

## 乐观锁
乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。  
乐观锁适用于多读的应用类型，这样可以提高吞吐量。

```
1. 例如，version 字段（比较跟上一次的版本号，如果一样则更新，如果失败则要重复读-比较-写的操作）
2. 在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。
```

### 乐观锁的实现
1. 使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。
2. Java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。




# Java 内存模型（Java Memory Model，JMM）
```
Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中。
每条线程还有自己的工作内存（Working Memory），
线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，
线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。
不同的线程之间也无法直接访问对方工作内存中的变量，线程间的变量值的传递均需要通过主内存来完成，
线程、主内存、工作内存三者的关系如下图：
```
![JMM](http://static2.iocoder.cn/images/JDK/2020_02_07/01.png)



