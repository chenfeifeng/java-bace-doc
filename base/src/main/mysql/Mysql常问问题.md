# 锁

# 索引
## InnoDB
1. 聚簇索引
  + B+Tree索引
    + 最左匹配原则
    + 索引字段要尽量的
    + 叶子节点保存下一个叶子节点的引用地址
    + 查询范围速度快

2. 非聚簇索引
3. 支持事务，支持行级锁，支持B-tree，FUll-test等索引，不支持哈希索引


## MyISAM
1. 哈希索引
   + 查询单条快，范围查询慢
2. 全文索引
   + 
   
# 事务隔离
1. read_uncommit(未提交读):可能脏读，不可重复读和幻读
2. read_commit(已提交读):可能不可重复读和幻读
3. repeatable_read(可重复读):可能出现幻读
4. serializable(可串行化)：不会出现并发问题，但是效率低

# MVCC多版本控制

# 日志
1. bin log
    + 用来主从辅助的逻辑记录
2. undo log
  + 用来回滚行记录到某个版本。ubdo log 一般是逻辑日志，根据每行进行记录
  + undo记录某数据被修改前的值，可以用来在事务失败时进行回滚 rollback
3. redo log
  + 通常是物理日志，记录的是数据也的物理修改，而不是某一行或者几行修改的怎么样，用来恢复提交后的物理数据页
  + redo记录某数据被修改后的值，可以用来回复未写入 data file的已成功事务更新的数据

# MySQL高可用方案
1. 主从或主主半同步复制
2. 半同步复制优化
3. 高可用架构优化
4. 共享存储
5. 分布式协议



---

# MySQL 主从复制的流程是怎么样的？
MySQL 的主从复制是基于如下 3 个线程的交互（多线程复制里面应该是 4 类线程）：
1. Master 上面的 binlog dump 线程，该线程负责将 master 的 binlog event 传到 slave 。
2. Slave 上面的 IO 线程，该线程负责接收 Master 传过来的 binlog，并写入 relay log 。
3. Slave 上面的 SQL 线程，该线程负责读取 relay log 并执行。
4. 如果是多线程复制，无论是 5.6 库级别的假多线程还是 MariaDB 或者 5.7 的真正的多线程复制， 
   SQL 线程只做 coordinator ，只负责把 relay log 中的 binlog 读出来然后交给 worker 线程，
   woker 线程负责具体 binlog event 的执行。

----

# 异步复制，全同步复制，半同步复制
## 异步复制
主库写入一个事务commit提交并执行完之后，，将日志记录到binlog，将结果反馈给客户端，最后将日志传输到从库。

## 半同步复制
主库写入一个事务commit提交并执行完之后，并不直接将请求反馈给前端应用用户，而是等待从库也接收到binlog日志并成功写入中继日志后，主库才返回commit操作成功给客户端。
半同步复制保障了事物执行后，至少有两份日志记录，一份在主库的binlog上 ，另一份至少在从库的中继日志Relay log上，这样就极大的保证了数据的一致性。

## 全同步复制
全同步复制，当主库提交事务之后，所有的从库节点必须收到、APPLY并且提交这些事务，然后主库线程才能继续做后续操作。但缺点是，主库完成一个事务的时间会被拉长，性能降低。


# MySQL几种备份方式（重点）
1. 逻辑备份：使用mysql自带的mysqldump工具进行备份。备份成sql文件形式。
   + 优点：最大好处是能够与正在运行的mysql自动协同工作，在运行期间可以确保备份是当时的点，它会自动将对应操作的表锁定，不允许其他用户修改(只能访问)。可能会阻止修改操作。sql文件通用方便移植。 
   + 缺点：备份的速度比较慢。如果是数据量很多的时候。就很耗时间。如果数据库服务器处在提供给用户服务状态，在这段长时间操作过程中，意味着要锁定表(一般是读锁定，只能读不能写入数据)。那么服务就会影响的。 
2. 物理备份：直接拷贝mysql的数据目录。 
   + 直接拷贝只适用于myisam类型的表。这种类型的表是与机器独立的。但实际情况是，你设计数据库的时候不可能全部使用myisam类型表。你也不可能因为myisam类型表与机器独立，方便移植，于是就选择这种表，这并不是选择它的理由。 
   + 缺点：你不能去操作正在运行的mysql服务器(在拷贝的过程中有用户通过应用程序访问更新数据，这样就无法备份当时的数据)可能无法移植到其他机器上去。 
3. 双机热备份
   + mysql数据库没有增量备份的机制。当数据量太大的时候备份是一个很大的问题。还好mysql数据库提供了一种主从备份的机制(也就是双机热备) 
   + 优点：适合数据量大的时候。现在明白了。大的互联网公司对于mysql数据备份，都是采用热机备份。搭建多台数据库服务器，进行主从复制。
   
----
# MySql日志
## redo log 和 undo log 的区别
### undo log
1. 为了实现事务原子性，要么全部完成commit，要么全部回滚rollback，Innodb用于实现mvcc（多版本并发控制）
2. 例如：将user=’A’ 改为 user=’B’，则undo log中会记录下user=’A’和事务版本等信息
3. 一旦事务完成，所有修改必须被记录下，保证数据一致性（后面redo log解释）

### redo log
1. 如果使用undo log作为持久化数据，意味着修改数据和undo log必须同时写入磁盘持久化，这必定带来巨大的磁盘io，解决方案为了平衡磁盘io和一致性，引入redo log。
2. 数据和undo log可定时从缓冲刷至磁盘，但是redo log必须实时写入磁盘，当系统奔溃时，可依据redo log进行数据重做。
3. InnoDB存储引擎层的日志。

### Undo+Redo
1. 为了保证持久性，必须在事务提交前将RedoLog持久化。
2. 数据不需要在事务提交前写入磁盘，而是缓存在内存中。
3. RedoLog保证事务的持久性。
4. UndoLog保证事务的原子性。
5. 有一个隐含的特点，数据必须要晚于redolog写入持久存

```
引用自：https://blog.csdn.net/mydriverc2/article/details/50629599

事务的简化过程
假设有A、B两个数据，值分别为1,2，现在修改为3、4
1. 事务开始。
2. 记录A=1到undolog。
3. 修改A=3。
4. 记录A=3到redolog。
5. 记录B=2到undolog。
6. 修改B=4。
7. 记录B=4到redolog
8. 将redolog写入磁盘
9. 事务提交。
```



## bin log 和 relay log 的区别
### bin log
1. redo log可以实现数据重做，那为什么要使用binlog？因为redo log是Innodb实现的物理日志，一旦涉及到多种存储引擎，无法进行重做。
2. bin log 记录下所有数据的更改，可用于本机数据恢复和主从同步。
3. 刷入磁盘的方式：每个1s刷入磁盘 | 每次事务提交刷入磁盘 | 每个1s刷入磁盘+每次事务提交刷入磁盘


### relay（中继） log：
1. Mysql 主节点将binlog写入本地，从节点定时请求增量binlog，主节点将binlog同步到从节点。
2. 从节点单独进程会将binlog 拷贝至本地 relaylog中。
4. 从节点定时重放relay log。



