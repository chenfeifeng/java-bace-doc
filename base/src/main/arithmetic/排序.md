# 选择排序

## 复杂度
![V2uifs.png](https://s2.ax1x.com/2019/06/11/V2uifs.png)


## 简单选择排序
+ 简单选择排序（Simple Selection Sort）是一种直观的排序算法，其思想是在未排序的序列中选出最小的元素和序列的首位元素交换，
+ 接下来在剩下的未排序序列中再选出最小元素与序列的第二位元素交换，以此类推，最后形成从小到大的已排序序列。


## 冒泡排序
1. 比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数
3. 针对所有的元素重复以上的步骤，除了最后一个
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较
5. 平均时间复杂度： O(n^2)

## 鸡尾酒排序
1. 鸡尾酒排序，也叫定向冒泡排序，是冒泡排序的一种改进。
2. 此算法与冒泡排序的不同处在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。
3. 他可以得到比冒泡排序稍微好一点的效能
4. ![图片](https://images2015.cnblogs.com/blog/739525/201603/739525-20160328160227004-680964122.gif)
5. 平均时间复杂度：O(n^2)

# 选择排序
1. 基本思想：
    + 初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；
    + 然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。
    + 以此类推，直到所有元素均排序完毕。
2. 注意选择排序与冒泡排序的区别：
    + 冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；
    + 而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。
3. 平均时间复杂度：O(n^2)

## 插入排序
### 直接插入排序(Straight Insertion Sort)
1. 基本思想是：
    + 把n个待排序的元素看成为一个有序表和一个无序表。
    + 开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，
    + 将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。
2. 平均时间复杂度：O(n^2)

### 二分插入排序
1. 基本思想
    + 二分插入排序的基本思想和插入排序一致；都是将某个元素插入到已经有序的序列的正确的位置；
    + 和直接插入排序的最大区别是，元素A[i]的位置的方法不一样；
    + 直接插入排序是从A[i-1]往前一个个比较，从而找到正确的位置；
    + 而二分插入排序，利用前i-1个元素已经是有序的特点结合二分查找的特点，找到正确的位置，从而将A[i]插入，并保持新的序列依旧有序；
2. 平均时间复杂度：O(n^2)


## 归并排序
1. 关键点:
    + 算法采用经典的分治（divide-and-conquer）
    + 策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)
2. 步骤
    + 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
    + 设定两个指针，最初位置分别为两个已经排序序列的起始位置
    + 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
    + 重复步骤3直到某一指针到达序列尾
    + 将另一序列剩下的所有元素直接复制到合并序列尾



## 快速排序
1. 快速排序的基本思想是：
    + 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小
    + 然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
2.  平均时间复杂度：O(nlogn)

## 希尔排序
1. 希尔排序实质上是一种分组插入方法
    + 对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，
    + 所有距离为gap的倍数的记录放在同一个组中；
    + 然后，对各组内的元素进行直接插入排序。
    + 这一趟排序完成之后，每一个组的元素都是有序的。
    + 然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，整个数列就是有序的。



# 参考资料
[常用排序算法总结1](https://www.cnblogs.com/eniac12/p/5329396.html#s1)  
[常用排序算法总结2](https://www.cnblogs.com/eniac12/p/5332117.html)  
