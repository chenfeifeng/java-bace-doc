# 事务四大特性（ACID）
1. 原子性(atomicity)
   + 一个事务是不可分割的工作单位，事务内的操作要么一起成功，要么一起失败
2. 一致性(consistency)
   + 一致性指的是事务必须使数据库从一个一致性状态变成另外一个一致性状态。
   + 事务执行前后都处于一致性状态
   + 例子：A和B转钱，不管怎么转，钱的总数一致。
3. 隔离性(isolation)：
   + 一个事务不能被其他事务干扰。
   + 即一个事务内部的操作及使用的数据在事务未提交之前，对其他事务是隔离的（不可见的），并发执行的各个事务之间不能互相影响。
4. 持久性(durability)：
   + 一个事务一旦提交成功，它修改的数据是永久性的

## 事务的 ACID 是通过 InnoDB 日志和锁来保证
1. 事务的隔离性是通过数据库锁的机制实现的，持久性通过 redo log（重做日志）来实现，原子性和一致性通过 Undo log（回滚日志） 来实现。
2. Undo Log 的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为 Undo Log）。然后进行数据的修改。如果出现了错误或者用户执行了 ROLLBACK 语句，系统可以利用 Undo Log 中的备份将数据恢复到事务开始之前的状态。
3. 和 Undo Log 相反，Redo Log 记录的是新数据的备份。在事务提交前，只要将 RedoLog 持久化即可，不需要将数据持久化。
4. 当系统崩溃时，虽然数据没有持久化，但是 Redo Log 已经持久化。系统可以根据 Redo Log 的内容，将所有数据恢复到最新的状态。


# 事务并发出现的问题
 1. 脏读
    + 当一个事务在处理的过程中读取到了其他事务未提交的数据，导致两个事务获得的数据不一致。
 2. 幻读
    + 指事务不是独立执行时候出现的情况。
    + 在第一个事务操作(修改)表所有行的某个数据时候，这时有另外一个事务进行插入数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。
    + 例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。
    + 幻读和不可重复读都是读取了另一条已经提交的事务(这点就脏读不同)，所不同的是不可重复读可能发生在update,delete操作中，而幻读发生在insert操作中。
 3. 不可重复读
    + 在一个事务处理的过程中，多次查询一批数据（条件相同），但是得到的结果不一致。这是由于在查询间隔，
    该事务需要用到的数据被另一个事务修改并提交了。
    + 与脏读的区别是，脏读读取的是另一个事务未提交的数据；不可重复读，读取的是另外一个事务已经读取的数据。   
   
# 数据库事务的四种隔离级别
1. read_commit:读可提交
  + 解决了脏读问题
  + 读取数据的事务允许其他事务继续访问该行数据，但是为提交的写事务，将会禁止其他事务操作。
  + 使用瞬间共享读锁和排他锁实现， 即事务需要对某些数据进行修改必须对这些数据加 X 锁，读数据时需要加上 S 锁，当数据读取完成后立刻释放 S 锁，不用等到事务结束。
2. read_uncommit:读不可提交
   + 解决更新丢失问题
   + 当一个事务开始写操作时候，不支持其他事务对该数据进行写操作，但是支持其他事务对该数据进行读取操作
   + 改隔离级别可以有排他锁进行实现。
3. repeatable_read:可重复读
   + 禁止不可重复读取和脏读取，但是有时可能出现幻读数据
   + 读取数据的事务将会禁止写事务（但是允许读事务），写事务则禁止任何其他事务。
   + 这可以通过“共享读锁”和“排他写锁”实现，即事务需要对某些数据进行修改必须对这些数据加 X 锁，读数据时需要加上 S 锁，当数据读取完成并不立刻释放 S 锁，而是等到事务结束后再释放。
4. serializable:可串行读
   + 解决了幻读的问题的
   + 提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。
   + 效率低

  
隔离级别   |  脏读（Dirty Read）  | 不可重复读（NonRepeatable Read） | 幻读（Phantom Read）
---|---|---|---|
read_uncommit | 可能| 可能 | 可能
read_commit | 不可能 | 可能 | 可能
repeatable_read | 不可能 | 不可能 | 可能
serializable | 不可能 | 不可能 | 不可能


# 锁相关
1. 排他锁：X锁，写锁
2. 共享锁：S锁，读锁
3. 读和写的关系：
   + 一个事务对数据加了X锁，那个就可以对这个数据进行读取和更新，其他事务无法对这个数据加锁
   + 一个事务对数据加了S锁，可以对这个数据进行读取操作。加锁期间，其他事务可以对数据进行S锁，但是不能执行X锁。
4. 即读写锁之间的关系可以概括为：多读单写
   
   
 # MVCC
 1. 多版本并发控制(Multi-Version Concurrency Control, MVCC)是MySQL中基于乐观锁理论实现隔离级别的方式，
    用于实现读已提交和可重复读取隔离级别的实现。
 2. 系统版本号：一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
 3. 事务版本号：事务开始时的系统版本号。
 4. 在MySQL中，会在表中每一条数据后面添加两个字段：
    + 创建版本号：创建一行数据时，将当前系统版本号作为创建版本号赋值
    + 删除版本号：删除一行数据时，将当前系统版本号作为删除版本号赋值
 ## 查询(select)
 1. 创建版本号<当前事务版本号
    + 保证取出的数据不会有后启动的事务中创建的数据。
    + 这也是为什么在开始的示例中我们不会查出后来添加的数据的原因
    + 解决了脏读和幻读以及不可重复读
 2. 删除版本号为空或者大于当前版本号
    + 保证了至少在该事务开启之前数据没有被删除，是应该被查出来的数据。

## 插入(insert)
1. insert时将当前的系统版本号赋值给创建版本号字段。
   
## 删除(delete)
1. 删除时将当前的系统版本号赋值给删除版本号字段，标识该行数据在那一个事务中会被删除，
2. 即使实际上在未commit时该数据没有被删除。根据select的规则后也不会查询到该数据。

## 修改(update)
1. 插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行，实际上这里的更新是通过delete和insert实现的。
  
## 快照读和当前读
1. 快照度：根据mvcc规则读取到历史数据
2. 当前度：读取数据库最新版本数据的方式

 
 # mysql常用的4中sql引擎
1. MyISAM
   + 不支持事务，不持之外键，访问速度快。对事务没要求以及查询或插入为主的应用可以用这个引擎来创建表。
2. InnoDB
   + InnoDB存储提供了 提交，回滚和奔溃回复能力的事务安全。
   + 但是对比MyISAM的存储引擎，InnoDB写的处理效率更差一些，并且会占用更多的磁盘空间以保留数据和索引。
3. MEMORY
   + MEMORY是在内存中来创表的，每个MEMORY表都会对应一个磁盘文件，格式为.frm。
   + MEMORY类型的表访问特别快，因为数据放在内存中，且默认使用HASH索引，但是当服务器一关闭，所有数据将丢失，但是表还是会存在
4. MERGE
   + Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，merge表本身并没有数据，对merge类型的表可以进行查询，更新，删除操作，这些操作实际上是对内部的MyISAM表进行的。
 
 
# 参考
1. [MySQL的可重复读级别能解决幻读吗](https://juejin.im/post/5c9040e95188252d92095a9e?utm_source=gold_browser_extension#heading-9)
2. [隔离机制示例](https://www.jianshu.com/p/4e3edbedb9a8)



# limit分页覆盖所有
