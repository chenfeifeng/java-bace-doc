# redis的两种持久化方式
1. rdb：以快照的形式，将数据存储在内存中，效率高，但是容易丢失数据。相当于mysql的dump
   + RDB方式的持久化是通过快照(snapshortting)完成的，当符合一定条件时Redis会自动将内存中所有数据完整的压缩存储到硬盘上。
   + RDB开启条件由2个参数 时间 和 改动次数构成。如：save 900 1
   + RDB文件由2个参数 dir 和 dbfilename 分别指定目录 和 文件名
   + RDB方式是Redis默认的持久化方式。
2. aof：写日志方式，相当于 MySQL 中的 binlog，推荐使用。
   + AOF是纯文本文件，会记录 Redis 的每次改动命令(不记录查询)。
   + AOF开启条件：appendonly yes
   + AOF文件由2个参数 dir 和 appendfilename 分别指定目录 和 文件名
   + AOF方式 默认情况下Redis并没有开启。
   + 策略：
      + 策略1：always(每次写入都会fsync同步到硬盘)
      + 策略2：everysec(默认，1s写1次)
      + 策略3：no(并非不写，交给系统控制预计30s写1次)
      
---
# Redis 的数据“过期”策略
1. 被动删除：当读/写一个已经过期的 key 时，会触发惰性删除策略，直接删除掉这个过期 key 。
2. 主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以 Redis 会定期主动淘汰一批已过期的 key 。
3. 主动删除：当前已用内存超过 maxmemory 限定时，触发主动清理策略，即 「数据“淘汰”策略」 。


---      
#  Redis集群机制
## 主从复制
1. 主服务器可以读写数据，从服务器只能读取数据
2. 初始化时，从服务器向主服务器发送sync命令，同步rdb快照数据
3. 然后将保存的快照文件和缓存的命令发送给slave
4. slave接收到快照文件和命令后加载快照文件和缓存的执行命令。
5. 复制初始化后，master每次接收到的写命令都会同步发送给slave，保证主从数据一致性。


## 哨兵
哨兵的作用是监控 redis系统的运行状况，他的功能如下：  
1. 集群监控：负责监控 redis master 和 slave 进程是否正常工作。
2. 消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。
3. 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。
4. 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。

### 工作方式：  
1. 每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。
2. 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）
3. 如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态
4. 当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）
5. 在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。
6. 当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。
7. 若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。

###  哨兵模式的优缺点
1. 优点
   + 哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。
   + 主从可以自动切换，系统更健壮，可用性更高。
   + 读写分离

2. 缺点
   + Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。
   + 每个服务器存储数据相同，浪费内存


## 集群
redis3.0上加入了cluster模式，实现的redis的分布式存储，也就是说每台redis节点上存储不同的内容。  
Redis-Cluster采用无中心结构,它的特点如下：  
1. 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。
2. 节点的fail是通过集群中超过半数的节点检测失效时才生效。
3. 客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。
   
### 工作方式
```
在redis的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383。
还有一个就是cluster，可以理解为是一个集群管理的插件。
当我们的存取的key到达的时候，redis会根据crc16的算法得出一个结果，然后把结果对 16384 求余数，
这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，
然后直接自动跳转到这个对应的节点上进行存取操作。
```
   
```
为了保证高可用，redis-cluster集群引入了主从模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。
当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。
如果主节点A和它的从节点A1都宕机了，那么该集群就无法再提供服务了。
```

### Redis的Hash一致性
#### 场景1
1. 如果4台缓存服务器已经不能满足我们的缓存需求，那么我们应该怎么做呢？
2. 假设：我们增加了一台缓存服务器，那么缓存服务器的数量就由4台变成了5台。
3. 那么原本hash(a.png) % 4 = 2 的公式就变成了hash(a.png) % 5 = ？ ， 可想而知这个结果肯定不是2的，这种情况带来的结果就是当服务器数量变动时，所有缓存的位置都要发生改变！
4. 换句话说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端数据库请求数据

#### 场景2
1. 假设4台缓存中突然有一台缓存服务器出现了故障，无法进行缓存，那么我们则需要将故障机器移除，
2. 但是如果移除了一台缓存服务器，那么缓存服务器数量从4台变为3台，也是会出现上述的问题！

#### 槽迁移
1. 当出现以上场景的时候，则需要进程槽solt的迁移
2. 槽迁移的过程中有一个不稳定状态，这个不稳定状态会有一些规则，这些规则定义客户端的行为，从而使得Redis Cluster不必宕机的情况下可以执行槽的迁移。
3. 数据转出槽，MIGRATING状态下当客户端请求的某个Key所属的槽处于MIGRATING状态的时候，影响有下面几条：
    + 如果Key存在则成功处理
    + 如果Key不存在，则返回客户端ASK，仅当这次请求会转向另一个节点，并不会刷新客户端中node的映射关系，也就是说下次该客户端请求该Key的时候，还会选择MasterA节点
    + 如果Key包含多个命令，如果都存在则成功处理，如果都不存在，则返回客户端ASK，如果一部分存在，则返回客户端TRYAGAIN，通知客户端稍后重试，这样当所有的Key都迁移完毕的时候客户端重试请求的时候回得到ASK，然后经过一次重定向就可以获取这批键
4. 数据转入槽，IMPORTING状态
    + 正常命令会被MOVED重定向，如果是ASKING命令则命令会被执行，从而Key没有在老的节点已经被迁移到新的节点的情况可以被顺利处理；
    + 如果Key不存在则新建
    + 没有ASKING的请求和正常请求一样被MOVED，这保证客户端node映射关系出错的情况下不会发生写错；

#### 键空间迁移
1. 键空间迁移是指当满足了槽迁移前提的情况下，我们就可以通过相关命令将槽1、2、3中的键空间从MasterA节点转移到MasterB节点，这个过程真正实现数据转移 
2. 通过dump，restore,del三部操作进行key空间的转移
![V84QSA.png](https://s2.ax1x.com/2019/06/02/V84QSA.png)
2. [资料链接](https://blog.csdn.net/tianpeng341204/article/details/78963850)





---

# 缓存穿透
1. 缓存穿透：
   + 当请求进入时候，首先去查询key是否存在，如果不存在，则进行数据库查询
   + 但是当每次以这个key访问时，都会去查询一下数据库，这叫做缓存穿透
2. 处理方案：
   + 首先当这个key第一次查询过数据库之后，给这个key设置一个值（设置失效时间）
   + 然后再次请求时候，会获取到这个key对应的值，即不需要多次查询数据库

缓存穿透：查询一个必然不存在的数据。比如文章表，查询一个不存在的id，每次都会访问DB，如果有人恶意破坏，很可能直接对DB造成影响。

# 缓存击穿(缓存并发)
1. 缓存击穿：
   + 是指某个极度“热点”数据在某个时间点过期时，恰好在这个时间点对这个 KEY 有大量的并发请求过来，这些请求发现缓存过期一般都会从 DB 加载数据并回设到缓存，
   + 但是这个时候大并发的请求可能会瞬间 DB 压垮。
   + 对于一些设置了过期时间的 KEY ，如果这些 KEY 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑这个个问题。
   + 缓存被“击穿”的问题，和缓存“雪崩“”的区别在于，前者针对某一 KEY 缓存，后者则是很多 KEY 
   + 缓存被“击穿”的问题，和缓存“穿透“”的区别在于，这个 KEY 是真实存在对应的值的。
2. 处理方案
   + 方案一：使用互斥锁：请求发现缓存不存在后，去查询 DB 前，使用分布式锁，保证有且只有一个线程去查询 DB ，并更新到缓存。
     + 获取分布式锁，直到成功或超时。如果超时，则抛出异常，返回。如果成功，继续向下执行。
     + 再去缓存中。如果存在值，则直接返回；如果不存在，则继续往下执行。 因为，获得到锁，可能已经被“那个”线程去查询过 DB ，并更新到缓存中了
     + 查询 DB ，并更新到缓存中，返回值。
   + 方案二：手动过期
     + 缓存上从不设置过期时间，功能上将过期时间存在 KEY 对应的 VALUE 里，
     + 如果发现要过期，通过一个后台的异步线程进行缓存的构建，也就是“手动”过期。通过后台的异步线程，保证有且只有一个线程去查询 DB



# 缓存雪崩(缓存失效)
1. 缓存雪崩：
   + 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。    
   + 和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。
2. 处理方案：
   + 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
   + 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。
   + 设置热点数据永远不过期


# 缓存失效(缓存雪崩)
1. 缓存失效：假如已有缓存的失效时间都是一样的，当某个时间，所以缓存同时失效了，此时又有较高的并发，会导致所有请求，初次都去db查询，导致db压力过大。
2. 处理方案：
   + 设置随机失效时间
   + 采用缓存并发的处理方案（加锁）
3. 缓存失效：
   + 如果缓存集中在一段时间内失效，DB的压力凸显。这个没有完美解决办法，但可以分析用户行为，尽量让失效时间点均匀分布。
   + 当发生大量的缓存穿透，例如对某个失效的缓存的大并发访问就造成了缓存雪崩。


# 缓存预热
1. 缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！
2. 解决思路：
    + 直接写个缓存刷新页面，上线时手工操作下；
    + 数据量不大，可以在项目启动的时候自动进行加载；
    + 定时刷新缓存；

---

# Redis 有几种数据“过期”策略
1. 被动删除：当读/写一个已经过期的 key 时，会触发惰性删除策略，直接删除掉这个过期 key 。
2. 主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以 Redis 会定期主动淘汰一批已过期的 key 。
3. 主动删除：当前已用内存超过 maxmemory 限定时，触发主动清理策略，即 「数据“淘汰”策略」 。


# redis 提供 6种数据淘汰策略
1. volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
5. allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
6. no-enviction（驱逐）：禁止驱逐数据

---
# 如何使用 Redis 实现分布式锁？
## 方案一：set 指令
1. 先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。
> SET key value [EX seconds] [PX milliseconds] [NX|XX]


## 对比 Zookeeper 分布式锁
1. 从可靠性上来说，Zookeeper 分布式锁好于 Redis 分布式锁。
2. 从性能上来说，Redis 分布式锁好于 Zookeeper 分布式锁。


---
# redis的集群机制
1. Replication（主从复制）
2. Sentinel（哨兵）
3. Twemproxy
4. Codis
5. Redis 3.0集群

---

# redis为什么这么快
1. 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；
2. 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；
3. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
4. 使用多路I/O复用模型，非阻塞IO；
5. 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

多路 I/O 复用模型：
1. 多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。
2. 这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。

# 为什么redis是单线程的
1. 官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。
2. 我们已经可以很清楚的解释了为什么Redis这么快，并且正是由于在单线程模式的情况下已经很快了，就没有必要在使用多线程了！但是，我们使用单线程的方式是无法发挥多核CPU 性能，不过我们可以通过在单机开多个Redis 实例来完善！



---


# Redis的线程模型
redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。  
它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。  
文件事件处理器的结构包含 4 个部分：  
1. 多个 socket
2. IO 多路复用程序
3. 文件事件分派器
4. 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）


---
# Redis部分面试题
## redis-和memcache区别
1. memcache全部存储内存，redis可以持久化
2. 数据类型支持
    + memcache只支持字符串
    + redis支持更多
3. value
    + memcache最大1m
    + redis最大1g

## redis对比memcache优势
1. redis的结构类型比memcache丰富
2. redis的速度比memcached快
3. redis可以持久化

## redis性能问题
1. Master不做rdb内存快照和aof持久化操作，选择slave进行存储
2. Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。
3. Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。
4. slave每个1s同步数据到aof
5. 主从结构最好是链表形似，Master <- Slave1 <- Slave2 <- Slave3...这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。



## MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据
1. 相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。redis 提供 6种数据淘汰策略
2. 可以使用 voltile-lru 策略


## Redis使用场景
1. 会话缓存（Session Cache）
    + 最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？
    + 幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。
2. 全页缓存（FPC）
    + 除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。
3. 队列
    + Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。
4. 排行榜/计数器
    + Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。
    + 所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：
        + 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：
        + ZRANGE user_scores 0 10 WITHSCORES
5. 发布/订阅
    + 发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。
    
    
## Redis 不同类型使用场景
### Pub/Sub
1. Redis的Pub/Sub系统可以构建实时的消息系统
 
### Sorted Sets
1. 和Sets相比，Sorted Sets增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，比如一个存储全班同学成绩的Sorted Sets，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。可以用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。
2. 排行榜应用，取TOP N操作
```
//将登录次数和用户统一存储在一个sorted set里,ZADD key score member
zadd login:login_times 5 1
zadd login:login_times 1 2
zadd login:login_times 2 3

//当用户登录时，对该用户的登录次数自增1
ret = r.zincrby("login:login_times", 1, uid)

//那么如何获得登录次数最多的用户呢，逆序排列取得排名前N的用户,ZREVRANGE key start stop [WITHSCORES]
ret = r.zrevrange("login:login_times", 0, N-1)
```
3. 游戏排行榜
```
// 添加分数
ZADD leaderboard <score> <username>
// 得到前100名高分用户很简单
ZREVRANGE leaderboard 0 99
// 用户的全球排名也相似，只需要
ZRANK leaderboard <username>

ZRANK key member
```

4. 范围查找
    + 有一个IP范围对应地址的列表，现在需要给出一个IP的情况下，迅速的查找到这个IP在哪个范围，也就是要判断此IP的所有地。

```
// 有下面两个范围，10－20和30－40
// A_start 10, A_end 20,B_start 30, B_end 40

// 添加
redis 127.0.0.1:6379> zadd ranges 10 A_start
redis 127.0.0.1:6379> zadd ranges 20 A_end
redis 127.0.0.1:6379> zadd ranges 30 B_start
redis 127.0.0.1:6379> zadd ranges 40 B_end

现在我需要查找15这个值在哪一个范围中，只需要进行如下的zrangbyscore查找：
redis 127.0.0.1:6379> zrangebyscore ranges (15 +inf LIMIT 0 1
1) "A_end"

//这个命令的意思是在Sorted Sets中查找大于15的第一个值。（+inf在Redis中表示正无穷大，15前面的括号表示>15而非>=15）
//查找的结果是A_end，由于所有值是按顺序排列的，所以可以判定15是在A_start到A_end区间上，也就是说15是在A这个范围里。至此大功告成。
//当然，如果你查找到的是一个start，比如咱们用25，执行下面的命令
redis 127.0.0.1:6379> zrangebyscore ranges (25 +inf LIMIT 0 1
1) "B_start"
返回结果表明其下一个节点是一个start节点，也就是说25这个值不处在任何start和end之间，不属于任何范围。
```

## Sets
1. Sets 就是一个集合，集合的概念就是一堆不重复值的组合。利用Redis提供的Sets数据结构，可以存储一些集合性的数据。
2. 交集，并集，差集：(Set)
```
//tag表使用集合来存储数据，因为集合擅长求交集、并集
sadd tag:ruby 1
sadd tag:ruby 2
sadd tag:web 2
sadd tag:erlang 3

//即属于ruby又属于web的书？
inter_list = redis.sinter("tag.web", "tag:ruby")

//即属于ruby，但不属于web的书？
inter_list = redis.sdiff("tag.ruby", "tag:web")

//属于ruby和属于web的书的合集？
 inter_list = redis.sunion("tag.ruby", "tag:web")

```

## Lists
1. Lists 就是链表，略有数据结构知识的人都应该能理解其结构。使用Lists结构，我们可以轻松地实现最新消息排行等功能。Lists的另一个应用就是消息队列，可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作Lists中某一段的api，你可以直接查询，删除Lists中某一段的元素。
2. 消息队列系统
    + 使用list可以构建队列系统，使用sorted set甚至可以构建有优先级的队列系统。
    + 比如：将Redis用作日志收集器
    + 实际上还是一个队列，多个端点将日志信息写入Redis，然后一个worker统一将所有日志写到磁盘。
3. 取最新N个数据的操作
```
//记录前N个最新登陆的用户Id列表，超出的范围可以从数据库中获得。
//把当前登录人添加到链表里
ret = r.lpush("login:last_login_times", uid)
//保持链表只有N位
ret = redis.ltrim("login:last_login_times", 0, N-1)
//获得前N个最新登陆的用户Id列表
last_login_list = r.lrange("login:last_login_times", 0, N-1)
```