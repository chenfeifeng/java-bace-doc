# G1（Garbage First）第一时间处理垃圾最多的区块

## 说明
G1算法将内存分为各个区域，区域内可能包含Y区和O区，每类区域空间可以是不连续的。  
虽然在清理这些区块时G1仍然需要暂停应用线程、但可以用相对较少的时间优先回收包含垃圾最多区块

## 特点
1. 并行与并发
   + G1能充分利用多CPU、多核环境下的硬件优势，
   + 使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，
   + 部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。
2. 分代收集
   + 与其他收集器一样，分代概念在G1中依然得以保留。
   + 虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，
   + 但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。
3. 空间整合
   + 与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，
   + 从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，
   + 这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。
   + 这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。
4. 可预测的停顿
   + 这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，
   + 但G1除了追求低停顿外，还能建立可预测的停顿时间模型，
   + 能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，
   + 这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。   


## 执行步骤
1. 初始标记-stw
2. 并发标记
3. 最终标记-stw
4. 筛选回收-stw


## G1和CMS的区别
1. G1在压缩空间方面有优势
2. G1通过将内存空间分成区域（Region）的方式避免内存碎片问题
3. Eden, Survivor, Old区不再固定、在内存使用效率上来说更灵活
4. G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象
5. G1在回收内存后会马上同时做合并空闲内存的工作、而CMS默认是在STW（stop the world）的时候做
6. G1会在Young GC中使用、而CMS只能在O区使用

## 一下场合更适用于G1
1. 服务端多核CPU、JVM内存占用较大的应用（至少大于4G）
2. 应用在运行过程中会产生大量内存碎片、需要经常压缩空间
3. 想要更可控、可预期的GC停顿周期；防止高并发下应用雪崩现象

