# 概念
## 公平锁
```
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```
构造函数中true时候，使用公平锁。

## 非公平锁
1. 构造函数传参为false时候
2. 默认无参构造函数为非公平锁
```
public ReentrantLock() {
    sync = new NonfairSync();
}
```

1. 在公平的锁上，线程按照他们发出请求的顺序获取锁，但在非公平锁上，则允许‘插队’：当一个线程请求非公平锁时，如果在发出请求的同时该锁变成可用状态，那么这个线程会跳过队列中所有的等待线程而获得锁。     非公平的ReentrantLock 并不提倡 插队行为，但是无法防止某个线程在合适的时候进行插队。
2. 在公平的锁中，如果有另一个线程持有锁或者有其他线程在等待队列中等待这个所，那么新发出的请求的线程将被放入到队列中。而非公平锁上，只有当锁被某个线程持有时，新发出请求的线程才会被放入队列中。

非公平锁性能高于公平锁性能的原因：
1. 在恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟。


1. 假设线程A持有一个锁，并且线程B请求这个锁。由于锁被A持有，因此B将被挂起。当A释放锁时，B将被唤醒，因此B会再次尝试获取这个锁。与此同时，如果线程C也请求这个锁，那么C很可能会在B被完全唤醒之前获得、使用以及释放这个锁。这样就是一种双赢的局面：B获得锁的时刻并没有推迟，C更早的获得了锁，并且吞吐量也提高了。
3. 当持有锁的时间相对较长或者请求锁的平均时间间隔较长，应该使用公平锁。在这些情况下，插队带来的吞吐量提升（当锁处于可用状态时，线程却还处于被唤醒的过程中）可能不会出现。


# AQS相关
[AQS源码详解](https://blog.csdn.net/pfnie/article/details/53191892)


## 对于非公平锁说法
其中当ReentrantLock使用非公平锁时候，线程A持有这个锁，当线程B请求的时候，发现获取不到该锁，则放在队列中进行阻塞等待。   
此时当线程C来请求该锁时，会出现几种情况：
1. 线程C请求时候，A刚好释放锁。此时
   + 线程C获取锁比唤醒线程B更快，则线程C得到锁,线程B放在队列中阻塞等待
   + 线程B唤醒比线程C获取更快，则线程B得到锁，线程C放在队列中阻塞等待。
2. 线程C请求时候，A未释放锁，则线程C加入队列中进行阻塞等待。线程A进行释放锁，期间未出现其他锁进行访问，则有队列中进行唤醒线程。--此时是线程B先被唤醒，并且拿到锁。


## 公平锁说法
其中当ReentrantLock使用公平锁时候，线程A持有这个锁，当线程B请求的时候，发现获取不到该锁，则放在队列中进行阻塞等待。
此时当线程C来请求该锁时，会出现几种情况：
1. 线程C请求时候，线程A刚好释放，但是由于是公平锁，队列中还存在线程B，则将线程C继续放在队列中进行阻塞等待，而将线程B进行唤醒，并且得到锁。
2. 线程C请求时候，线程A未释放，但是由于是公平锁，队列中还存在线程B，则将线程C继续放在队列中进行阻塞等待。
等到A释放之后，根据队列中先进先出的原则将线程B进行唤醒，并且得到锁。




# 简化版

## 非公平锁
```
简化版的步骤：（非公平锁的核心）

基于CAS尝试将state（锁数量）从0设置为1

A、如果设置成功，设置当前线程为独占锁的线程；

B、如果设置失败，还会再获取一次锁数量，

B1、如果锁数量为0，再基于CAS尝试将state（锁数量）从0设置为1一次，如果设置成功，设置当前线程为独占锁的线程；

B2、如果锁数量不为0或者上边的尝试又失败了，查看当前线程是不是已经是独占锁的线程了
    + 如果是，则将当前的锁数量+1；
    + 如果不是，则将该线程封装在一个Node内，并加入到等待队列中去。等待被其前一个线程节点唤醒。

```

## 公平锁
```
简化版的步骤：（公平锁的核心）

获取一次锁数量，

B1、如果锁数量为0，如果当前线程是等待队列中的头节点，基于CAS尝试将state（锁数量）从0设置为1一次，如果设置成功，设置当前线程为独占锁的线程；

B2、如果锁数量不为0或者当前线程不是等待队列中的头节点或者上边的尝试又失败了，查看当前线程是不是已经是独占锁的线程了，
    + 如果是，则将当前的锁数量+1；
    + 如果不是，则将该线程封装在一个Node内，并加入到等待队列中去。等待被其前一个线程节点唤醒。

```





## 公平锁和非公平锁的点
1. 线程会进行尝试获取锁
   + 公平锁：判断CLH队列头是不是自己，是自己才会尝试获取锁
   + 非公平锁：不管当前线程在CLH队列的某个位置都会进行尝试获取锁
   + 当获取锁失败时，都会会将线程放在CLH队列的尾部
2. 当线程都存入CLH时候都会执行acquireQueued()方法[当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。]
3. 新线程进来尝试获取锁：
  + 公平锁：如果CLH队列中有线程阻塞，则肯定获取失败
  + 非公平锁：直接进行尝试获取锁，如果刚好，当前无线程占有锁，则该线程有可能直接获取锁，无需等待。





[ReentrantLock源码解析1--获得非公平锁与公平锁lock()](https://www.cnblogs.com/java-zhao/p/5131544.html)

[ReentrantLock源码解析2--释放锁unlock()](http://www.cnblogs.com/java-zhao/p/5133402.html)