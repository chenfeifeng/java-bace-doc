# 分布式


# 分布式事务
分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。
即一次大操作由N个服务器去进行小操作组成，这些小操作必须全部成功或者全部失败。


## CAP原理
1. C:一致性
   + 对某个指定的客户端来说，读操作能返回最新的写操作。
   + 【一致性】指的是多个副本之间是否能够保持一致的特性。在一致性的需求下，当一个系统再数据一致的状态下执行
         更新操作后，应该保证系统数据仍然处于一致的状态
2. A:可用性
   + 非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应）。
   +【可用性】是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果、
3. P:分区容错性
   + 当出现网络分区后，系统能够继续工作。打个比方，这个集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。
   + 【分区容错性】分布式系统再遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生故障了。

### cap的理解
```
只能满足CA不能满足P的理解
    异地DB，保证C需要双写，如果双写？ DB_0同步到DB_1的过程网络有问题，则一直挂起，A不满足。单台DB满足CA 但是不满足P
    例如：MySQL集群的的异步复制，单台CA,集群AP
  
只能满足AP不能满足C的理解
    异地DB，master写成功（异步复制到slve） 满足AP 不满足C
    
 只能满足CP不能满足A的理解
    异地DB，保证CP，必须同步双写， DB_0同步到DB_1的过程网络有问题，则一直挂起，A不满足

------------------------------------------------------------------------------------------------------------
当然在目前海量数据面前，往往会舍弃C，而保证AP，对与数据的一致性，只要求最终一致即可，在过程中是会出现差异的状况，比如在不同
地方的人对某个新闻或者商品进行评论，在一定时刻内是不需要实时显示出来的，只要保证最终会出现即可。

```

### CAP使用情况
1. MySQL 主从异步复制是 AP 系统。
   + master执行sql,生成binlog,并进行commit
   + salve收到binlog日志并写入relaylog中，并进行执行，且写入本地binlog
2. MySQL 主从半同步复制是 AP 系统。
3. Zookeeper 是 CP 系统。
4. Redis 主从同步是 AP 系统。
5. Eureka 主从同步是 AP 系统。
6. [分布式系统理论（一）：CAP定理 ](https://my.oschina.net/lhztt/blog/915533)

----

# XA方式
## 概念
X/Open 组织（即现在的 Open Group ）定义了分布式事务处理模型。 X/Open DTP 模型（ 1994 ）包括：  
1. 应用程序（ AP ）
2. 事务管理器（ TM ）
3. 资源管理器（ RM ）
4. 通信资源管理器（ CRM ）
一般，常见的事务管理器（ TM ）是交易中间件，常见的资源管理器（ RM ）是数据库，常见的通信资源管理器（ CRM ）是消息中间件，下图是X/Open DTP模型： 
 
```
一般的编程方式是这样的：
1. 配置 TM ，通过 TM 或者 RM 提供的方式，把 RM 注册到 TM。可以理解为给 TM 注册 RM 作为数据源。一个 TM 可以注册多个 RM。
2. AP 从 TM 获取资源管理器的代理（例如：使用JTA接口，从TM管理的上下文中，获取出这个TM所管理的RM的JDBC连接或JMS连接）
   AP 向 TM 发起一个全局事务。这时，TM 会通知各个 RM。XID（全局事务ID）会通知到各个RM。
3. AP 通过 TM 中获取的连接，间接操作 RM 进行业务操作。这时，TM 在每次 AP 操作时把 XID(包括所属分支的信息)传递给 RM，RM 正是通过这个 XID 关联来操作和事务的关系的。
4. AP 结束全局事务时，TM 会通知 RM 全局事务结束。开始二段提交，也就是prepare - commit的过程。
```

## 扩展
1. 二阶段提交是 XA 的标准实现。它将分布式事务的提交拆分为 2 个阶段：prepare 和 commit/rollback 。  
  + 第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。
  + 第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。

2. 开启 XA 全局事务后，所有子事务会按照本地默认的隔离级别锁定资源，并记录 undo 和 redo 日志。然后由 TM 发起 prepare 投票，询问所有的子事务是否可以进行提交：
  + 当所有子事务反馈的结果为 “yes” 时，TM 再发起 commit 。
  + 若其中任何一个子事务反馈的结果为“no”，TM 则发起 rollback 。
  + 如果在 prepare 阶段的反馈结果为 “yes” ，而 commit 的过程中出现宕机等异常时，则在节点服务重启后，可根据 XA recover 再次进行 commit 补偿，以保证数据的一致性。

3. 优点
  + 尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于 MySQL 是从 5.5 开始支持。

4. 缺点
  + 单点问题：事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。
  + 同步阻塞：在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。
  + 数据不一致：两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit 的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了 commit 操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。

# TCC方式
1. TCC 模型是把锁的粒度完全交给业务处理，它需要每个子事务业务都实现Try-Confirm / Cancel 接口。
2. TCC 模式本质也是 2PC ，只是 TCC 在应用层控制。
3. TCC 模式需要代码侵入

+ Try
  + 尝试执行业务
  + 完成所有业务检查（一致性）
  + 预留必须业务资源（准隔离性）
+ Confirm
  + 确认执行业务；
  + 真正执行业务，不作任何业务检查
  + 只使用Try阶段预留的业务资源
  + Confirm 操作满足幂等性
+ Cancel
  + 取消执行业务
  + 释放Try阶段预留的业务资源
  + Cancel操作满足幂等性


## 示例
下面对TCC模式下，A账户往B账户汇款100元为例子，对业务的改造进行详细的分析：  
汇款服务和收款服务分别需要实现，Try-Confirm-Cancel 接口，并在业务初始化阶段将其注入到 TCC 事务管理器中。

![图片](http://static2.iocoder.cn/4da5bc0df774ef90e97c6358eb7e632f)

1. 汇款服务
  + Try：
    + 检查A账户有效性，即查看A账户的状态是否为“转帐中”或者“冻结”
    + 检查A账户余额是否充足
    + 从A账户中扣减 100 元，并将状态置为“转账中”
    + 预留扣减资源，将从 A 往 B 账户转账 100 元这个事件存入消息或者日志中
  + Confirm:
    + 不做任何操作
  + Cancel：
    + A 账户增加 100 元
    + 从日志或者消息中，释放扣减资源

2. 收款服务
  + Try：
    + 检查 B 账户账户是否有效；
  + Confirm:
    + 读取日志或者消息，B 账户增加 100 元
    + 从日志或者消息中，释放扣减资源；
  + Cancel：
    + 不做任何操作


----
# 本地消息表
![VMre3j.png](https://s2.ax1x.com/2019/05/30/VMre3j.png)

---
# 聊聊可靠消息最终一致性方案
这个的意思，基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。  
[![VMUDpt.png](https://s2.ax1x.com/2019/05/30/VMUDpt.png)](https://imgchr.com/i/VMUDpt)

1. A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；
2. 如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；
3. 如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；
4. mq 会自动定时轮询所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。
5. 这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。
6. [资料](http://www.iocoder.cn/RocketMQ/message-transaction/?vip)

---
# 分布式锁
1. 基于数据库实现分布式锁

2. 基于缓存（redis，memcached，tair）实现分布式锁 

3. 基于Zookeeper实现分布式锁
   
   
---

# 幂等处理方案
1. token机制，防止页面重复提交
    + 每个请求都带上一个唯一的token
    + 该token将在redis中存储，获取一次之后立即删除，生成新的token返回 
2. 悲观锁 
    + 获取数据的时候加锁获取。select * from table_xxx where id='xxx' for update; 
    + 注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的；
    + 悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用；

3. 乐观锁
    + 乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。
    
4. 分布式锁
    + 如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，
    + 然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。
    + 要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)；
    
5. select + insert
    + 并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了。注意：核心高并发流程不要用这种方法；

6. 状态机幂等
    + 在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。
    + 注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助