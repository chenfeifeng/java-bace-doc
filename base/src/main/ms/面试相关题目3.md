## 锁的升级
锁的四种状态：无锁状态，偏向锁状态，轻量级锁状态，重量级锁状态（从低到高）  
JVM对Sychronized进行了优化，将Sycronized分为三种锁的级别：偏向锁，轻量级锁，重量级锁。 


### 偏向锁
1. 为什么要引入偏向锁？
```
因为经过HotSpot的作者大量的研究发现，大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁，
因此如果每次都要竞争锁会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入的偏向锁。
偏向锁偏向的是线程。不会主动释放锁，直到检查栈帧信息，才会变化状态。
```
2. 偏向锁的升级
```
当线程1访问代码块并获取锁对象时，会在java对象头和栈帧中记录偏向的锁的threadID，因为偏向锁不会主动释放锁，
因此以后线程1再次获取锁的时候，需要比较当前线程的threadID和Java对象头中的threadID是否一致，如果一致（还是线程1获取锁对象），
则无需使用CAS来加锁、解锁；如果不一致（其他线程，如线程2要竞争锁对象，而偏向锁不会主动释放因此还是存储的线程1的threadID），
那么需要查看Java对象头中记录的线程1是否存活，如果没有存活，那么锁对象被重置为无锁状态，其它线程（线程2）可以竞争将其设置为偏向锁；
如果存活，那么立刻查找该线程（线程1）的栈帧信息，如果还是需要继续持有这个锁对象，那么暂停当前线程1，撤销偏向锁，升级为轻量级锁，
如果线程1 不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程。

```


## 轻量级锁
1. 为什么要引入轻量级锁？
轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。  
因为阻塞线程需要CPU从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放。

2. 轻量级锁什么时候升级为重量级锁？
  + 线程1获取轻量级锁时会先把锁对象的对象头MarkWord复制一份到线程1的栈帧中创建的用于存储锁记录的空间（称为DisplacedMarkWord），然后使用CAS把对象头中的内容替换为线程1存储的锁记录（DisplacedMarkWord）的地址；
  + 如果在线程1复制对象头的同时（在线程1CAS之前），线程2也准备获取锁，复制了对象头到线程2的锁记录空间中，但是在线程2CAS的时候，发现线程1已经把对象头换了，线程2的CAS失败，那么线程2就尝试使用自旋锁来等待线程1释放锁。
  + 但是如果自旋的时间太长也不行，因为自旋是要消耗CPU的，因此自旋的次数是有限制的，比如10次或者100次，如果自旋次数到了线程1还没有释放锁，或者线程1还在执行，线程2还在自旋等待，这时又有一个线程3过来竞争这个锁对象，那么这个时候轻量级锁就会膨胀为重量级锁。重量级锁把除了拥有锁的线程都阻塞，防止CPU空转。

3. 轻量级锁的升级重量级锁
  + 线程在自己的栈桢中创建锁记录 LockRecord
  + 将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中
  + 将锁记录中的owner指向对象锁对象
  + 将锁对象的对象头的MarkWord替换为指向锁记录的指针

![1](https://user-gold-cdn.xitu.io/2018/8/22/165614893a59be34?w=721&h=344&f=png&s=42033)  
![2](https://user-gold-cdn.xitu.io/2018/8/22/165614960abf2f0e?w=549&h=343&f=png&s=35522)



4. 注意
  + 为了避免无用的自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁了；偏向锁升级为轻量级锁也不能再降级为偏向锁。一句话就是锁可以升级不可以降级，但是偏向锁状态可以被重置为无锁状态 


![锁区别](https://img-blog.csdn.net/2018032217003676)

## 锁粗化
1. 同步块的作用范围应该尽可能小，仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，缩短阻塞时间，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。 
2. 但是加锁解锁也需要消耗资源，如果存在一系列的连续加锁解锁操作，可能会导致不必要的性能损耗。 
3. 锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁，避免频繁的加锁解锁操作。



## 锁消除
1. Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，经过逃逸分析，
2. 去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间


## 锁撤销
由于偏向锁失效了，那么接下来就得把该锁撤销，锁撤销的开销花费还是挺大的，其大概的过程如下：
1. 在一个安全点停止拥有锁的线程。
2. 遍历线程栈，如果存在锁记录的话，需要修复锁记录和Markword，使其变成无锁状态。
3. 唤醒当前线程，将当前锁升级成轻量级锁。
4, 所以，如果某些同步代码块大多数情况下都是有两个及以上的线程竞争的话，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭


## 自旋锁
1. 所谓自旋，就是指当有另外一个线程来竞争锁时，这个线程会在原地循环等待，而不是把该线程给阻塞，直到那个获得锁的线程释放锁之后，这个线程就可以马上获得锁的。
2. 注意，锁在原地循环的时候，是会消耗cpu的。
3. 轻量级锁适用于那些同步代码块执行的很快的场景，这样，线程原地等待很短很短的时间就能够获得锁了。
4. 自旋锁的一些问题
   + 如果同步代码块执行的很慢，需要消耗大量的时间，那么这个时侯，其他线程在原地等待空消耗cpu。
   + 本来一个线程把锁释放之后，当前线程是能够获得锁的，但是假如这个时候有好几个线程都在竞争这个锁的话，那么有可能当前线程会获取不到锁，还得原地等待继续空循环消耗cup，甚至有可能一直获取不到锁。
   + 所以基于这个问题，我们必须给线程空循环设置一个次数，当线程超过了这个次数，我们就认为，继续使用自旋锁就不适合了，此时锁会再次膨胀，升级为重量级锁。
   + 默认情况下，自旋的次数为10次，用户可以通过-XX:PreBlockSpin来进行更改。

## 自选适应锁
1. 所谓自适应自旋锁就是线程空循环等待的自旋次数并非是固定的，而是会动态着根据实际情况来改变自旋等待的次数。
2. 原理
   + 假如一个线程1刚刚成功获得一个锁，当它把锁释放了之后，线程2获得该锁，并且线程2在运行的过程中，此时线程1又想来获得该锁了，但线程2还没有释放该锁，
   + 所以线程1只能自旋等待，但是虚拟机认为，由于线程1刚刚获得过该锁，那么虚拟机觉得线程1这次自旋也是很有可能能够再次成功获得该锁的，所以会延长线程1自旋的次数。
   + 如果对于某一个锁，一个线程自旋之后，很少成功获得该锁，那么以后这个线程要获取该锁时，是有可能直接忽略掉自旋过程，直接升级为重量级锁的，以免空循环等待浪费资源。


## 锁升级资料
1. https://blog.csdn.net/qq_38462278/article/details/81976428


---

2. zk的羊群效应
   + 在分布式事务锁中，N各节点监听最小临时顺序节点，当最小临时顺序节点被删除时，会唤醒所有的后续节点，这就是羊群效应
   + 改善，每个节点只监听上一个节点。
3. zk实现分布式事务锁
   + 建立根节点为lock
   + 每当线程访问时，调用lock或者trylock方法进行获取锁，根据lock_name+顺序创建临时顺序子节点
   + 将lock下的所有子节点排序，校验当前节点是不是最小节点，如果是，则获取到锁
   + 如果不是，则进行监听上一节点删除时间，并进行阻塞住
   + 当调用完共享资源后，调用unlock（）方法，关闭zk，进而可以引发监听事件，释放该锁。 
4. redis实现分布式事务锁
   + 使用set(key,value,NX,PX,time）创建唯一的有失效时间的key，创建成果获取锁，创建失败，进行阻塞
   + 删除时候，使用 rua 代码，进行原子操作，先查询，后删除
5. dubbo的延迟暴露
   + 配置dubbo的延迟暴露时间
   + 延迟5秒暴露接口  <dubbo:service delay="5000" /> 
   + 等spring初始化完成后暴露接口  <dubbo:service delay="-1" />
6. 线程安全的单例实现
   + 
7. 设计模式
   + 


---
